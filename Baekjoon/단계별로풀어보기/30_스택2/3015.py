# 스택 문제는 어렵지 않게 풀리는 것 같다. 문제는 DP ㅠㅠ

import sys
from bisect import bisect_left

N = int(input())
# bisect를 이용하기 위해 음수의 값을 넣는다. bisect는 오름차순 정렬 상태에서만 동작하기 때문.
heights = [-int(sys.stdin.readline()) for _ in range(N)]

# 스택은 항상 오름차순으로 정렬된 상태를 유지한다.(실제 키값은 내림차순이다. 음수를 집어넣기 떄문)
stack = []
count = 0

for h in heights:
    # 현재 키 h보다(실제로는 -h) 스택 끝에 있는 키가 더 작다면 해당 키를 스택에서 삭제해야 한다.
    # 스택에 있던 값은 자기보다 큰 사람을 마주하게 되면 더이상 뒤에 오는 사람을 볼수 없기 때문이다.
    # 이때 스택 마지막에 있던 값이 h보다 크거나 같을때 까지 계속 제거해야 한다.
    # 딱 한 사람만이 아닌 h보다 키가 작은 사람들 모두 더이상 뒤에 오는 사람을 볼수 없기 떄문이다.
    # 또한 스택의 마지막 키를 제거할때마다 count를 1씩 증가시켜야 한다.
    # 왜냐하면 스택은 키가 작아지는 순으로 정렬되므로 스택의 마지막에 있는 사람은 항상 h 키의 사람을 볼수 있기 때문이다.
    # 음수를 넣었기 때문에 부호가 반대로 됨에 주의!
    while stack and stack[-1] > h:
        count += 1
        stack.pop()

    # 스택의 마지막에 있는 사람은 h보다 키가 크거나 같은 사람이다.
    # 스택의 마지막에 있는 사람이 h보다 키가 크면 h는 그사람만 볼수 있고, 그사람보다 앞에 있는 사람은 전부 볼수 없기 때문에
    # count를 1만 증가시키면 된다.
    # 하지만 스택의 마지막에 있는 사람이 h와 키가 같다면 그사람 바로 앞의 사람도 볼수 있다.
    # 따라서 스택의 마지막에 있는 사람들 중 키가 h와 같은 사람들의 수만큼 count를 증가시켜야 한다.
    # 그사람들 전부 볼수 있기 때문이다.
    # 이때 이분 탐색으로 키가 h와 같은 사람의 수를 찾아야 한다. 선형 탐색으로 찾으면 시간 초과가 발생한다.
    left = bisect_left(stack, h)
    count += len(stack) - left

    # 키가 h로 같은 사람들 바로 앞에 사람이 있다면, 그사람까지는 볼수 있다. 따라서 count를 1 증가시킨다.
    if left != 0:
        count += 1

    stack.append(h)

print(count)