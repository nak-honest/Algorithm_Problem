# 문제 분류가 이분 탐색인지 몰랐다면 못 풀었을 것 같다..
# 좋은 문제이다.


# 기본적으로는 dp로 푸는 LIS와 비슷하게 접근한다.
# 기존 dp는 A의 첫번째 원소부터 순차적으로 하나씩 가지고 와서 해당 원소를 가지고 만들수 있는 최대 길이를 찾는다.
# 즉 A[i]를 가지고 올때, dp[0] ~ dp[i-1] 중에서 A[i] 보다 작으면서 가장 큰 dp의 값에 1을 더한값이 dp[i+1]이 된다.
# 예를들어 A[i] 보다 작은 값들 중에서 dp 값이 가장 큰 값이 A[j]라고 하면, A[j]를 끝으로 하는 증가하는 수열의 길이가 dp[j]인 것이고,
# 이 수열의 끝에 A[i]를 붙이면 A[i]를 끝으로 하는 증가하는 수열이 된다. 그리고 그 길이 dp[i] = dp[j] + 1이 되는 것이다.

# 이 아이디어에서 문제는 A[i]보다 작으면서 가장 큰 dp 값을 찾기 위해 A[0] ~ A[i-1] 까지 전부 뒤져봐야 하므로 O(n^2)이 된다는 것이다.
# 따라서 앞의 모든 원소를 다 찾는 것 대신 다른 방식으로 A[i]를 끝으로 하는 가장 긴 증가하는 수열의 길이를 구해야한다.

# 즉 A[i]를 끝으로 하는 가장 긴 증가하는 수열에서 A[i] 바로 앞의 값을 A[j]라 하면 이 A[j]를 빠르게 찾는 것이 중요한데,
# 이를 다른 방식의 dp를 이용해서 빠르게 찾을 수 있다.

# 먼저 dp[n] = A[j]의 의미는 A[j]를 끝으로하는 증가하는 수열의 최대 길이가 n이라는 것이다.
# 따라서 dp[n] = A[j] 를 찾으면 A[i]를 끝으로 하는 증가하는 수열의 최대길이가 n + 1 이 되는 것을 알 수 있다.
# 그런데 이러한 규칙을 적용하게 되면 dp[n] > dp[n-1]이어야 함을 알 수 있다.
# 왜냐하면 길이가 n인 증가하는 수열의 가장 마지막 원소가 dp[n]인데, 이는 길이가 n-1인 증가하는 수열에 dp[n]을 붙인 것이 되기 때문이다.
# 그런데 수열이 증가하기 때문에 길이가 n-1인 증가하는 수열의 마지막 원소보다 dp[n]이 커야하므로 dp[n] > dp[n-1]이 된다는 것이다.

# 즉 dp는 오름차순으로 이루어진다는 것을 알 수 있다.
# 그런데 여기서 한가지 더 생각해보아야 할 것은 최대 길이가 겹치는 원소들이 생길때 이다.
# 예를들어 A[i]가 18인데 dp[j]가 17이고 dp[j+1]이 20이라 해보자.
# 일단 A[i]를 생각하기 전에는 길이가 j+1인 증가하는 가장 긴 수열의 끝 원소가 dp[j+1]임을 알 수 있다.
# 그런데 A[i] 또한 dp[j] 뒤에 붙이면 그 수열의 길이가 j+1이 되기 때문에 A[i]도 dp[j+1]이 될 수 있다.
# 그렇다면 dp[j+1]을 그대로 냅둬야 할까 아니면 A[i]로 바꾸어야 할까?

# 이 문제는 가장 긴 부분수열의 길이를 구하는 것이지 원소를 구하는 것이 아니기 때문에 일단 dp[j+1]을 A[i]로 바꾸는 것은 괜찮다.
# 즉 dp[j+2]는 해당 원소를 가지고 오는 순간의 dp[j+1]값이 유지될 필요가 없다는 것이다.

# 그렇다면 dp[j+1]의 값이 작으면 작을 수록 좋기 때문에 dp[j+1]을 A[i]로 대체하는 것이 좋다.
# dp[j+1]의 값이 작을 수록 새로운 원소를 가지고 올때 그 뒤에 붙일 가능성이 더 높아지기 떄문이다.
# 만약 새로운 원소 A[k] = 19라고 하면 dp[j+1]이 18이라면 dp[j+2]에 A[k]를 넣을 수 있지만,
# 만약 dp[j+1]이 20이라면 A[k]가 dp[j+1]보다 작아서 dp[j+2]에 A[k]를 넣을 수 없게 된다.
# 그런데 실제로는 A[k]를 끝으로 하는 가장 긴 수열의 길이는 A[i]를 끝으로 하는 수열 뒤에 붙일 수 있으므로 j+2가 되어야 한다.
# 따라서 dp[j+1] = 18이어야 한다는 것이고 이는 dp의 원소가 최소값이 되도록 해야한다는 것이다.

# 그리고 마지막으로 dp[j] < A[i] < dp[j+1]을 찾아서 dp[j+1]을 업데이트 해 주어야 하는데,
# 이때 dp는 오름차순으로 정렬되어 있기 때문에 이분탐색으로 dp[j]를 찾을 수 있다.
# 그러면 시간 복잡도가 O(n log n) 이 된다. 기존의 dp와 다르게 탐색을 이분탐색으로 찾기 때문이다.

# 이렇게 A의 모든 원소를 순차적으로 하나씩 가지고 오면서 dp를 모두 업데이트 했을때
# dp의 가장 큰 인덱스 값(len(dp) - 1)이 가장 긴 부분 수열의 길이가 된다.


import sys

N = int(input())
A = list(map(int, sys.stdin.readline().split()))

# 처음에 dp에는 A의 첫번째 원소를 집어넣는다.
# 이는 dp[1] = A[0]이기 때문에 길이가 1인 가장 긴 부분 수열의 마지막 원소가 A[0]라는 것을 의미한다.
dp = [0, A[0]]

# 가장 긴 부분수열의 길이를 저장한다. 즉 dp의 가장 큰 인덱스를 저장한다.
max_len = 1

# A의 모든 원소를 순차적으로 하나씩 가지고 온다.
for a in A[1:]:
    # 만약 a가 dp[1]보다 작거나 같다면, a 앞에 붙일 수 있는 부분 수열이 없다는 것을 의미한다.
    # 따라서 dp[1]을 a로 대체한다.
    if dp[1] >= a:
        dp[1] = a
        continue
    # a가 dp[-1]보다 크다는 것은 dp의 가장 마지막 원소보다 a가 크다는 것이기 때문에 dp의 끝에 a를 추가해야 한다.
    # 왜냐하면 a를 마지막 원소로하는 부분 수열은 dp[-1] 원소를 마지막으로하는 부분 수열 뒤에 a를 붙인 것이기 때문이다.
    elif dp[-1] < a:
        dp.append(a)
        max_len += 1
        continue
    # 인덱스 범위가 벗어나지 않도록 하기 위해 마지막 원소가 a와 같은지 확인한다. 만약 같다면 업데이트할 것이 없으므로 A의 다음 원소를 가지고 온다.
    elif dp[-1] == a:
        continue


    # 위의 if문 조건에 하나도 걸리지 않았다는 것은 A[j] < a < A[j+1] 을 만족하는 j가 존재한다는 것이다.
    # 이 j를 이분탐색으로 찾는다.

    diff = max_len // 2
    cur = diff
    j = 1

    while diff > 0:
        diff //= 2

        if dp[cur] < a:
            j = cur
            cur += diff
        elif dp[cur] > a:
            cur -= diff
        else:
            break

    while dp[j] < a:
        j += 1

    dp[j] = a

print(max_len)
